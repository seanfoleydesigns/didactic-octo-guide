<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>Squip - Daily Grid Puzzle</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Match the target pattern in as few moves as possible! A challenging daily grid puzzle game where clicking tiles flips adjacent neighbors. New puzzle every day!">
    <meta name="keywords" content="puzzle game, daily puzzle, grid game, logic puzzle, brain teaser, squip, tile flipping game">
    <meta name="author" content="Squip">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://squip.io">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://squip.io">
    <meta property="og:title" content="Squip - Daily Grid Puzzle">
    <meta property="og:description" content="Match the target pattern in as few moves as possible! A challenging daily grid puzzle game. New puzzle every day!">
    <meta property="og:image" content="https://raw.githubusercontent.com/[username]/[repo]/main/squip-logo.svg">
    <meta property="og:site_name" content="Squip">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:url" content="https://squip.io">
    <meta name="twitter:title" content="Squip - Daily Grid Puzzle">
    <meta name="twitter:description" content="Match the target pattern in as few moves as possible! A challenging daily grid puzzle game.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/[username]/[repo]/main/squip-logo.svg">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="https://raw.githubusercontent.com/[username]/[repo]/main/squip-logo.svg">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/[username]/[repo]/main/squip-logo.svg">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#fefefe">
    
    <!-- Preconnect to external domains -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.counter.dev">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Squip",
      "description": "A challenging daily grid puzzle game where clicking tiles flips adjacent neighbors. Match the target pattern in as few moves as possible!",
      "url": "https://squip.io",
      "genre": "Puzzle",
      "gamePlatform": "Web Browser",
      "operatingSystem": "Any",
      "image": "https://raw.githubusercontent.com/[username]/[repo]/main/squip-logo.svg",
      "publisher": {
        "@type": "Organization",
        "@id": "Squip",
        "name": "Squip",
        "email": "contact@squip.io"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>
    
    <!-- Analytics -->
    <script src="https://cdn.counter.dev/script.js" data-id="edb14b17-4009-4579-b33d-6fd7ec0a330e" data-utcoffset="-4"></script>
    
    <!-- Analytics -->
    <script src="https://cdn.counter.dev/script.js" data-id="edb14b17-4009-4579-b33d-6fd7ec0a330e" data-utcoffset="-4"></script>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --primary-color: #0ea5e9;
            --primary-hover: #0284c7;
            --primary-light: #38bdf8;
            --primary-dark: #525252;
            --primary-bg: #e0f2fe;
            --primary-rgb: 14, 165, 233;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: 100dvh;
            background: #fefefe;
            font-family: 'Poppins', sans-serif;
            color: #1a1a1a;
            padding: 10px 20px 20px 20px;
            padding-bottom: env(safe-area-inset-bottom, 20px);
            overflow: auto;
        }

        #game-container {
            text-align: center;
            max-width: 500px;
            width: 100%;
            max-height: calc(100vh - 40px);
            max-height: calc(100dvh - 40px);
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px 20px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.08);
            backdrop-filter: blur(10px);
        }

        header {
            margin-bottom: 15px;
            position: relative;
        }

        h1 {
            font-size: 38px;
            font-weight: 900;
            letter-spacing: 0.1em;
            margin-bottom: 5px;
            background: linear-gradient(to right, #1a1a1a, #666);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .settings-btn {
            position: absolute;
            top: 0;
            right: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #e0e0e0;
            background: white;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .settings-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            transform: scale(1.1);
        }

        .settings-btn svg {
            width: 20px;
            height: 20px;
        }

        .help-btn {
            position: absolute;
            top: 45px;
            right: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #e0e0e0;
            background: white;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .help-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            transform: scale(1.1);
        }

        .help-btn svg {
            width: 20px;
            height: 20px;
        }

        .stats-btn {
            position: absolute;
            top: 90px;
            right: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #e0e0e0;
            background: white;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .stats-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            transform: scale(1.1);
        }

        .stats-btn svg {
            width: 20px;
            height: 20px;
        }

        #subtitle {
            color: #666;
            font-size: 12px;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        #stats {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-bottom: 15px;
            font-size: 14px;
            flex-wrap: wrap;
        }

        .stat {
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 16px;
        }

        .optimal-hint {
            font-size: 12px;
            color: var(--primary-color);
            margin-left: 4px;
        }

        #game-area {
            position: relative;
            margin-bottom: 20px;
            text-align: center;
        }

        #game-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .grid {
            display: grid;
            gap: 4px !important;
            grid-gap: 4px !important;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 12px;
            position: relative;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin: 0 auto;
            width: fit-content;
            height: fit-content;
            overflow: visible;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        #player-grid,
        #target-grid {
            grid-template-columns: repeat(3, 72px);
            grid-template-rows: repeat(3, 72px);
            min-width: 232px;
            min-height: 232px;
            max-width: 232px;
            max-height: 232px;
        }

        .cell {
            background: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: block;
            box-sizing: border-box;
            width: 72px;
            height: 72px;
            touch-action: manipulation;
        }

        button.cell {
            font-family: inherit;
            font-size: inherit;
            line-height: 1;
            padding: 0;
            margin: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            text-align: center;
            vertical-align: middle;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), transparent 50%);
            opacity: 1;
            transition: opacity 0.2s;
        }

        .cell.dark {
            background: #2d2d2d;
        }

        .cell.dark::before {
            opacity: 0;
        }

        .cell:hover:not(.animating) {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(var(--primary-rgb), 0.5);
        }

        @media (hover: none) and (pointer: coarse) {
            .cell:hover {
                transform: none;
                box-shadow: none;
            }
        }

        .cell.preview-light {
            background: var(--primary-light) !important;
        }

        .cell.preview-dark {
            background: var(--primary-dark) !important;
        }

        .cell.preview-selected {
            position: relative;
            box-sizing: border-box;
        }

        .cell.preview-selected::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 3.5px dashed currentColor;
            border-radius: 10px;
            pointer-events: none;
        }

        .cell.preview-light.preview-selected::after {
            color: #1a1a1a;
        }

        .cell.preview-dark.preview-selected::after {
            color: #ffffff;
        }

        .cell.preview-selected:not(.preview-light):not(.preview-dark)::after {
            color: #666;
        }

        .cell.preview-affected {
            position: relative;
            box-sizing: border-box;
        }

        .cell.preview-affected::after {
            content: '';
            position: absolute;
            top: 1px;
            left: 1px;
            right: 1px;
            bottom: 1px;
            border: 2px dashed currentColor;
            border-radius: 7px;
            opacity: 0.5;
            pointer-events: none;
        }

        .cell.preview-light.preview-affected::after {
            color: #1a1a1a;
        }

        .cell.preview-dark.preview-affected::after {
            color: #ffffff;
        }

        .cell.animating {
            animation: flip 0.4s ease-in-out;
        }

        @keyframes flip {
            0% { transform: scale(1) rotateY(0); }
            50% { transform: scale(1.2) rotateY(90deg); }
            100% { transform: scale(1) rotateY(180deg); }
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(var(--primary-rgb), 0.3);
            transform: scale(0);
            animation: ripple-effect 0.6s ease-out;
            pointer-events: none;
        }

        @keyframes ripple-effect {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* Overlay Styles */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: white;
            border-radius: 16px;
            padding: 28px;
            max-width: 480px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: none;
            border: none;
            font-size: 32px;
            color: #666;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .close-btn:hover {
            background: #f0f0f0;
        }

        .modal h2 {
            font-size: 26px;
            font-weight: 700;
            margin: 0 0 8px 0;
            color: #1a1a1a;
        }

        .modal .subtitle {
            color: #666;
            font-size: 15px;
            margin: 0 0 20px 0;
            text-align: center;
        }

        .tutorial-section {
            margin: 20px 0;
            text-align: left;
        }

        .tutorial-section h3 {
            font-size: 17px;
            font-weight: 600;
            margin: 0 0 14px 0;
            color: #1a1a1a;
        }

        .example-grid {
            margin: 20px 0;
            text-align: center;
        }

        .example-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .example-item {
            flex: 1;
            min-width: 120px;
            max-width: 150px;
        }

        .mini-grid {
            display: grid;
            grid-template-columns: repeat(3, 30px);
            grid-template-rows: repeat(3, 30px);
            gap: 3px;
            background: #f0f0f0;
            padding: 3px;
            border-radius: 8px;
            margin: 0 auto 10px;
            width: fit-content;
            height: fit-content;
        }

        .mini-cell {
            border-radius: 4px;
            transition: all 0.2s;
            width: 100%;
            height: 100%;
        }

        .mini-cell.light {
            background: var(--primary-color);
        }

        .mini-cell.dark {
            background: #2d2d2d;
        }

        .mini-cell.highlight {
            box-shadow: 0 0 0 2px #fbbf24;
        }

        .mini-cell.center-highlight {
            box-shadow: 0 0 0 3px #ef4444;
            transform: scale(1.1);
        }

        .example-text {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
            margin: 0;
            text-align: center;
        }

        .example-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
            text-align: center;
        }

        .rule-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin: 10px 0;
        }

        .rule-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            color: #666;
        }

        .rule-text {
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .tutorial-footer {
            margin-top: 28px;
            text-align: center;
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
        }

        .play-btn {
            background: var(--primary-color);
            color: white;
            padding: 10px 38px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .play-btn:hover {
            background: var(--primary-hover);
        }

        /* Result Modal */
        .result-modal {
            text-align: center;
            padding: 36px;
            max-width: 420px;
        }

        /* Solution Modal */
        .solution-modal {
            text-align: center;
            padding: 36px;
            max-width: 420px;
        }

        #solution-steps {
            margin-top: 24px;
        }

        .solution-step {
            margin: 20px 0;
        }

        .solution-grid {
            display: grid;
            gap: 4px;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 12px;
            margin: 0 auto;
            width: fit-content;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
        }

        .solution-cell {
            background: var(--primary-color);
            border-radius: 6px;
            position: relative;
            transition: all 0.2s;
        }

        .solution-cell.dark {
            background: #2d2d2d;
        }

        .solution-cell.clicked {
            box-shadow: 0 0 0 2px #ef4444;
            transform: scale(1.05);
            z-index: 1;
        }

        .solution-cell.affected {
            box-shadow: 0 0 0 2px #fbbf24;
        }

        .solution-arrow {
            font-size: 24px;
            color: #666;
            margin: 16px 0;
        }

        .result-header {
            margin-bottom: 28px;
        }

        .result-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            margin-top: 24px;
        }

        .result-btn {
            padding: 11px 28px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .share-btn {
            background: var(--primary-color);
            color: white;
        }

        .share-btn:hover {
            background: var(--primary-hover);
        }

        .solution-btn {
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            padding: 9px 26px;
        }

        .solution-btn:hover {
            background: rgba(var(--primary-rgb), 0.1);
            border-color: var(--primary-hover);
            color: var(--primary-hover);
        }

        #target-display {
            margin-top: 10px;
            padding-top: 16px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
        }

        #target-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #666;
            margin-bottom: 6px;
        }

        #target-grid {
            transform: scale(0.65);
            opacity: 0.6;
            pointer-events: none;
            width: auto !important;
            height: auto !important;
            margin: -20px auto;
        }

        #actions {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 8px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #reset-btn {
            background: #ef4444;
            color: white;
            width: 100px;
        }

        #reset-btn:hover:not(.disabled) {
            background: #dc2626;
        }

        #reset-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #undo-btn {
            background: transparent;
            color: #666;
            border: 2px solid #e0e0e0;
            width: 100px;
            padding: 8px 16px;
        }

        #undo-btn:hover:not(.disabled) {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        #undo-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #share-btn {
            background: var(--primary-color);
            color: white;
            width: 120px;
        }

        #share-btn:hover:not(.disabled) {
            background: var(--primary-hover);
        }

        #share-btn.disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
            opacity: 1;
        }

        #solution-btn {
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            width: 120px;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        #solution-btn:hover:not(.disabled) {
            background: rgba(var(--primary-rgb), 0.1);
            border-color: var(--primary-hover);
            color: var(--primary-hover);
        }

        #message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            color: var(--primary-color);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        #message.show {
            opacity: 1;
        }

        .particles {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--primary-color);
            border-radius: 50%;
            animation: particle-float 1s ease-out forwards;
        }

        @keyframes particle-float {
            to {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        .completed-indicator {
            display: inline-block;
            margin-left: 8px;
            padding: 4px 12px;
            background: #4ade80;
            color: #000;
            font-size: 11px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: transform 0.2s;
        }

        .completed-indicator:not(.failed):hover {
            transform: scale(1.05);
        }

        .completed-indicator.failed {
            background: #ef4444;
            color: white;
        }

        .completed-indicator.perfect {
            background: #fbbf24;
            color: #000;
        }

        .contact-footer {
            margin-top: 20px;
            font-size: 11px;
            color: #999;
            text-align: center;
        }

        /* Confirmation Modal */
        .confirmation-dialog {
            text-align: center;
        }

        .confirmation-dialog p {
            margin: 10px 0;
            line-height: 1.6;
            color: #666;
        }

        .confirmation-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 24px;
        }

        .danger-btn {
            background: #ef4444;
            color: white;
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .danger-btn:hover {
            background: #dc2626;
        }

        .cancel-btn {
            background: transparent;
            color: #666;
            border: 2px solid #e0e0e0;
            padding: 8px 22px;
        }

        .cancel-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* Settings Modal Styles */
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-info {
            flex: 1;
            padding-right: 20px;
        }

        .setting-info h3 {
            font-size: 16px;
            font-weight: 600;
            margin: 0 0 6px 0;
            color: #1a1a1a;
        }

        .setting-info p {
            font-size: 13px;
            color: #666;
            margin: 0;
            line-height: 1.5;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e0e0e0;
            transition: .3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-switch.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .toggle-switch.disabled .toggle-slider {
            cursor: not-allowed;
        }

        /* Color Picker Styles */
        .color-picker {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            justify-content: flex-end;
        }

        .color-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            position: relative;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: #1a1a1a;
            transform: scale(1.1);
        }

        .color-option.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        @media (min-width: 501px) {
            .cell {
                width: 72px !important;
                height: 72px !important;
                min-width: 72px !important;
                min-height: 72px !important;
                max-width: 72px !important;
                max-height: 72px !important;
            }
        }

        @media (max-width: 500px) {
            body {
                padding: 5px 10px 10px 10px;
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }

            #game-container {
                padding: 20px 15px;
                max-height: none;
                height: auto;
            }

            h1 {
                font-size: 32px;
            }

            .modal {
                padding: 20px;
                max-width: 95%;
                max-height: 85vh;
            }

            .settings-btn {
                width: 32px;
                height: 32px;
                top: 0;
            }

            .settings-btn svg {
                width: 18px;
                height: 18px;
            }

            .help-btn {
                width: 32px;
                height: 32px;
                top: 40px;
            }

            .help-btn svg {
                width: 18px;
                height: 18px;
            }

            .stats-btn {
                width: 32px;
                height: 32px;
                top: 80px;
            }

            .stats-btn svg {
                width: 18px;
                height: 18px;
            }

            #stats {
                gap: 20px;
            }

            .result-actions {
                flex-direction: row;
                gap: 10px;
            }

            .result-btn {
                flex: 1;
            }

            .example-row {
                flex-direction: row;
                gap: 10px;
                justify-content: center;
                flex-wrap: wrap;
            }

            .example-item {
                flex: 0 0 auto;
                min-width: auto;
                max-width: none;
                width: 90px;
            }

            .mini-grid {
                grid-template-columns: repeat(3, 24px);
                grid-template-rows: repeat(3, 24px);
                gap: 2px;
                padding: 2px;
                margin: 0 auto 6px;
            }

            .mini-cell.center-highlight {
                box-shadow: 0 0 0 2px #ef4444;
            }

            .mini-cell.highlight {
                box-shadow: 0 0 0 1px #fbbf24;
            }

            .solution-cell.clicked {
                box-shadow: 0 0 0 2px #ef4444;
            }

            .solution-cell.affected {
                box-shadow: 0 0 0 1px #fbbf24;
            }

            .example-label {
                font-size: 10px;
                margin-bottom: 4px;
            }

            .example-item .example-text {
                font-size: 11px;
            }

            .grid {
                display: grid !important;
                gap: 4px !important;
                grid-gap: 4px !important;
                margin: 0 auto !important;
                padding: 4px !important;
                background: #f0f0f0 !important;
                border-radius: 12px !important;
                width: fit-content !important;
                height: fit-content !important;
                box-sizing: border-box !important;
            }

            #player-grid,
            #target-grid {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                grid-template-rows: repeat(3, 1fr) !important;
                gap: 4px !important;
                grid-gap: 4px !important;
                width: 232px !important;
                height: 232px !important;
            }

            .cell {
                width: 100% !important;
                height: 100% !important;
                border-radius: 8px !important;
            }

            #actions {
                flex-direction: row;
                gap: 8px;
            }

            #solution-btn,
            #share-btn {
                flex: 1;
            }

            #game-controls {
                flex-direction: row;
                gap: 8px;
            }

            #reset-btn,
            #undo-btn {
                flex: 1;
            }

            .confirmation-buttons {
                flex-direction: column;
                width: 100%;
            }

            .danger-btn,
            .cancel-btn {
                width: 100%;
            }

            .color-picker {
                justify-content: center;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <header>
            <h1>SQUIP</h1>
            <div id="subtitle">Daily Puzzle #<span id="puzzle-number"></span></div>
            
            <!-- Settings button -->
            <button class="settings-btn" onclick="Game.showSettings()" title="Settings">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                    <circle cx="12" cy="12" r="3"></circle>
                </svg>
            </button>
            
            <button class="help-btn" onclick="Game.showTutorial()" title="How to play">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M7 7a3 3 0 0 1 6 0c0 1.5-1.5 2-3 2.5v1.5"></path>
                    <circle cx="10" cy="15" r="0.5" fill="currentColor"></circle>
                </svg>
            </button>
            
            <button class="stats-btn" onclick="Game.showStats()" title="View stats">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
                    <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
                    <path d="M4 22h16"></path>
                    <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
                    <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
                    <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
                </svg>
            </button>
        </header>

        <div id="stats">
            <div class="stat">
                Moves: <span class="stat-value" id="moves-count">0</span>
                <span class="optimal-hint">(Optimal: <span id="optimal-moves">?</span>)</span>
            </div>
        </div>

        <div id="game-area">
            <div id="player-grid" class="grid"></div>
        </div>

        <div id="game-controls">
            <button id="reset-btn" onclick="Game.resetTiles()">Reset</button>
            <button id="undo-btn" onclick="Game.undo()" class="disabled">Undo</button>
        </div>

        <div id="target-display">
            <div id="target-label">Target Pattern</div>
            <div id="target-grid" class="grid"></div>
        </div>

        <div id="actions">
            <button id="solution-btn" onclick="Game.showSolution()">Solution</button>
            <button id="share-btn" onclick="Game.shareResults()" class="disabled">Share</button>
        </div>

        <div class="contact-footer">
            Questions/Comments? Reach out at contact@squip.io
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="overlay">
        <div class="modal">
            <button class="close-btn" onclick="Game.closeTutorial()">&times;</button>
            <h2>How To Play</h2>
            <p class="subtitle">Match the target pattern in as few moves as possible!</p>
            
            <div class="tutorial-section">
                <h3>The Rules</h3>
                
                <p class="example-text" style="text-align: left; margin: 0 0 20px 0;">Click any tile to flip it and its adjacent neighbors. Each position has a different pattern - tiles in the center flip in a plus (+) shape, edge tiles flip in a T shape, and corner tiles flip in an L shape. Your goal is to match the daily target pattern!</p>
                
                <div class="example-row">
                    <div class="example-item">
                        <div class="example-label">Center</div>
                        <div class="mini-grid">
                            <div class="mini-cell light"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell dark center-highlight"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                        </div>
                        <p class="example-text">Plus pattern</p>
                    </div>
                    
                    <div class="example-item">
                        <div class="example-label">Edge</div>
                        <div class="mini-grid">
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell dark center-highlight"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell light"></div>
                        </div>
                        <p class="example-text">T pattern</p>
                    </div>
                    
                    <div class="example-item">
                        <div class="example-label">Corner</div>
                        <div class="mini-grid">
                            <div class="mini-cell dark center-highlight"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell dark highlight"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell light"></div>
                            <div class="mini-cell light"></div>
                        </div>
                        <p class="example-text">L pattern</p>
                    </div>
                </div>
                
                <p class="example-text" style="text-align: left; margin: 20px 0; background: rgba(var(--primary-rgb), 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(var(--primary-rgb), 0.3);">
                    <strong>Tips:</strong> Each tile toggles between blue and black when flipped. Remember that clicking a tile affects multiple tiles at once! The optimal solution exists - every puzzle can be solved in the number of moves shown.
                </p>
                
                <div style="margin-top: 20px;">
                    <div class="rule-item">
                        <div class="rule-icon">•</div>
                        <div class="rule-text">You have <strong>unlimited moves</strong> to find the solution</div>
                    </div>
                    <div class="rule-item">
                        <div class="rule-icon">•</div>
                        <div class="rule-text"><strong>Undo</strong> reverts your last move</div>
                    </div>
                    <div class="rule-item">
                        <div class="rule-icon">•</div>
                        <div class="rule-text"><strong>Reset</strong> clears the board if you get stuck</div>
                    </div>
                    <div class="rule-item">
                        <div class="rule-icon">•</div>
                        <div class="rule-text">View the <strong>Solution</strong> if you give up (ends your attempt)</div>
                    </div>
                </div>
            </div>
            
            <div class="tutorial-footer">
                <button class="play-btn" onclick="Game.closeTutorial()">Start Playing</button>
            </div>
        </div>
    </div>

    <!-- Result Overlay -->
    <div id="result-overlay" class="overlay">
        <div class="modal result-modal">
            <button class="close-btn" onclick="Game.closeResult()">&times;</button>
            <div class="result-header">
                <h2 id="result-title">Nice!</h2>
                <p class="subtitle" id="result-subtitle">You solved it!</p>
            </div>
            
            <div class="result-actions" id="result-actions">
                <button class="result-btn solution-btn" onclick="Game.viewSolutionFromResult()">Solution</button>
                <button class="result-btn share-btn" onclick="Game.shareResults()">Share</button>
            </div>
        </div>
    </div>

    <!-- Solution Overlay -->
    <div id="solution-overlay" class="overlay">
        <div class="modal solution-modal">
            <button class="close-btn" onclick="Game.closeSolution()">&times;</button>
            <h2>Solution</h2>
            <p class="subtitle">Here's the optimal solution:</p>
            <div id="solution-steps"></div>
        </div>
    </div>

    <!-- Solution Confirmation Overlay -->
    <div id="solution-confirm-overlay" class="overlay">
        <div class="modal confirmation-dialog">
            <h2>View Solution?</h2>
            <p>Viewing the solution will end your current attempt and mark today's puzzle as incomplete.</p>
            <p><strong>Are you sure you want to give up?</strong></p>
            <div class="confirmation-buttons">
                <button class="danger-btn" onclick="Game.confirmSolution()">Yes, Show Solution</button>
                <button class="cancel-btn" onclick="Game.cancelSolution()">Keep Trying</button>
            </div>
        </div>
    </div>

    <!-- Stats Overlay -->
    <div id="stats-overlay" class="overlay">
        <div class="modal">
            <button class="close-btn" onclick="Game.closeStats()">&times;</button>
            <h2>Your Stats</h2>
            <div id="stats-content"></div>
        </div>
    </div>

    <!-- Settings Overlay -->
    <div id="settings-overlay" class="overlay">
        <div class="modal">
            <button class="close-btn" onclick="Game.closeSettings()">&times;</button>
            <h2>Settings</h2>
            <div id="settings-content">
                <div class="setting-item">
                    <div class="setting-info">
                        <h3>Tap to Preview</h3>
                        <p>When enabled, tap once to preview a move, then tap again to confirm. Mobile and tablet only.</p>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="mobile-preview-toggle" onchange="Game.toggleMobilePreview()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <div class="setting-info">
                        <h3>Color Theme</h3>
                        <p>Choose your preferred color for tiles and UI elements.</p>
                    </div>
                    <div class="color-picker">
                        <div class="color-option" style="background: #0ea5e9" data-color="blue" onclick="Game.changeColor('blue')"></div>
                        <div class="color-option" style="background: #10b981" data-color="green" onclick="Game.changeColor('green')"></div>
                        <div class="color-option" style="background: #8b5cf6" data-color="purple" onclick="Game.changeColor('purple')"></div>
                        <div class="color-option" style="background: #f97316" data-color="orange" onclick="Game.changeColor('orange')"></div>
                        <div class="color-option" style="background: #ec4899" data-color="pink" onclick="Game.changeColor('pink')"></div>
                        <div class="color-option" style="background: #06b6d4" data-color="cyan" onclick="Game.changeColor('cyan')"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="message"></div>
    <div class="particles" id="particles"></div>

    <script>
        const Game = {
            // State
            grid: [],
            targetGrid: [],
            moves: 0,
            optimalMoves: 0,
            solutionMoves: [],
            isComplete: false,
            isAnimating: false,
            moveHistory: [],
            previewIndex: -1,
            mobilePreviewEnabled: false,
            isTouchDevice: false,
            currentColor: 'blue',
            
            // Constants
            GRID_SIZE: 3,
            MIN_MOVES: 3,
            MAX_MOVES: 7,
            
            // BFS Solver to find minimum moves
            findMinimumMoves(startState, targetState) {
                // Convert states to strings for comparison
                const targetStr = targetState.join('');
                const startStr = startState.join('');
                
                if (startStr === targetStr) return 0;
                
                // BFS queue: [state, moves, path]
                const queue = [[startState, 0, []]];
                const visited = new Set([startStr]);
                
                while (queue.length > 0) {
                    const [currentState, moves, path] = queue.shift();
                    
                    // Try clicking each position
                    for (let i = 0; i < 9; i++) {
                        // Create a copy and apply the move
                        const newState = [...currentState];
                        this.applyMove(newState, i);
                        const newStateStr = newState.join('');
                        
                        // Check if we reached the target
                        if (newStateStr === targetStr) {
                            return moves + 1;
                        }
                        
                        // Add to queue if not visited
                        if (!visited.has(newStateStr) && moves + 1 < 15) { // Prevent infinite loops
                            visited.add(newStateStr);
                            queue.push([newState, moves + 1, [...path, i]]);
                        }
                    }
                }
                
                return -1; // Should never happen
            },
            
            // Color themes
            colorThemes: {
                blue: {
                    primary: '#0ea5e9',
                    hover: '#0284c7',
                    light: '#38bdf8',
                    dark: '#525252',
                    bg: '#e0f2fe',
                    rgb: '14, 165, 233'
                },
                green: {
                    primary: '#10b981',
                    hover: '#059669',
                    light: '#34d399',
                    dark: '#525252',
                    bg: '#d1fae5',
                    rgb: '16, 185, 129'
                },
                purple: {
                    primary: '#8b5cf6',
                    hover: '#7c3aed',
                    light: '#a78bfa',
                    dark: '#525252',
                    bg: '#ede9fe',
                    rgb: '139, 92, 246'
                },
                orange: {
                    primary: '#f97316',
                    hover: '#ea580c',
                    light: '#fb923c',
                    dark: '#525252',
                    bg: '#fed7aa',
                    rgb: '249, 115, 22'
                },
                pink: {
                    primary: '#ec4899',
                    hover: '#db2777',
                    light: '#f472b6',
                    dark: '#525252',
                    bg: '#fce7f3',
                    rgb: '236, 72, 153'
                },
                cyan: {
                    primary: '#06b6d4',
                    hover: '#0891b2',
                    light: '#22d3ee',
                    dark: '#525252',
                    bg: '#cffafe',
                    rgb: '6, 182, 212'
                }
            },
            
            // Storage
            memoryStorage: {},
            
            // Elements
            elements: {
                playerGrid: document.getElementById('player-grid'),
                targetGrid: document.getElementById('target-grid'),
                movesCount: document.getElementById('moves-count'),
                optimalMoves: document.getElementById('optimal-moves'),
                resetBtn: document.getElementById('reset-btn'),
                undoBtn: document.getElementById('undo-btn'),
                shareBtn: document.getElementById('share-btn'),
                solutionBtn: document.getElementById('solution-btn'),
                message: document.getElementById('message'),
                tutorialOverlay: document.getElementById('tutorial-overlay'),
                resultOverlay: document.getElementById('result-overlay'),
                solutionOverlay: document.getElementById('solution-overlay'),
                solutionConfirmOverlay: document.getElementById('solution-confirm-overlay'),
                statsOverlay: document.getElementById('stats-overlay'),
                settingsOverlay: document.getElementById('settings-overlay'),
                puzzleNumber: document.getElementById('puzzle-number'),
                subtitle: document.getElementById('subtitle')
            },
            
            // Initialize
            init() {
                // Detect touch device
                this.isTouchDevice = ('ontouchstart' in window) || 
                                   (navigator.maxTouchPoints > 0) || 
                                   (navigator.msMaxTouchPoints > 0);
                
                // Load mobile preview preference
                const savedPreference = this.load('squip-mobile-preview');
                if (this.isTouchDevice) {
                    // For touch devices: default to true if no saved preference exists
                    if (savedPreference === null) {
                        this.mobilePreviewEnabled = true;
                        this.save('squip-mobile-preview', true);
                    } else {
                        this.mobilePreviewEnabled = savedPreference;
                    }
                } else {
                    // For non-touch devices: always disabled
                    this.mobilePreviewEnabled = false;
                }
                
                // Load color preference
                const savedColor = this.load('squip-color-theme');
                if (savedColor && this.colorThemes[savedColor]) {
                    this.currentColor = savedColor;
                    this.applyColorTheme(savedColor);
                }
                
                this.updatePuzzleNumber();
                this.loadOrCreatePuzzle();
                this.checkFirstTime();
                this.updateUndoButton();
                this.initializeStats();
            },
            
            // Initialize stats
            initializeStats() {
                const stats = this.load('squip-stats');
                if (!stats) {
                    this.save('squip-stats', {
                        currentStreak: 0,
                        longestStreak: 0,
                        perfectScores: 0,
                        lastCompletedDate: null
                    });
                }
            },
            
            // Update stats when puzzle completed
            updateStats(isPerfect) {
                const stats = this.load('squip-stats') || {
                    currentStreak: 0,
                    longestStreak: 0,
                    perfectScores: 0,
                    lastCompletedDate: null
                };
                
                const { today } = this.getDateInfo();
                const todayStr = today.toISOString().split('T')[0];
                
                // Check if this puzzle was already completed today
                const { dayNumber } = this.getDateInfo();
                const saveKey = `squip-day-${dayNumber}`;
                const saved = this.load(saveKey);
                if (saved && saved.statsUpdated) {
                    return stats; // Already updated stats for this puzzle
                }
                
                // Update perfect scores
                if (isPerfect) {
                    stats.perfectScores++;
                }
                
                // Update streak
                if (stats.lastCompletedDate) {
                    const lastDate = new Date(stats.lastCompletedDate);
                    const dayDiff = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
                    
                    if (dayDiff === 1) {
                        // Consecutive day
                        stats.currentStreak++;
                    } else if (dayDiff > 1) {
                        // Missed days - reset to 1
                        stats.currentStreak = 1;
                    }
                    // dayDiff === 0 means same day, don't update streak
                } else {
                    // First completion
                    stats.currentStreak = 1;
                }
                
                // Update longest streak
                if (stats.currentStreak > stats.longestStreak) {
                    stats.longestStreak = stats.currentStreak;
                }
                
                stats.lastCompletedDate = todayStr;
                this.save('squip-stats', stats);
                
                // Mark this puzzle as having updated stats
                if (saved) {
                    saved.statsUpdated = true;
                    this.save(saveKey, saved);
                }
                
                return stats;
            },
            
            // Reset streak when failing
            resetStreak() {
                const stats = this.load('squip-stats');
                if (stats) {
                    stats.currentStreak = 0;
                    this.save('squip-stats', stats);
                }
            },
            
            getDateInfo() {
                const today = new Date();
                const startDate = new Date('2025-07-29');
                const todayLocal = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                const startLocal = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                const dayNumber = Math.floor((todayLocal - startLocal) / (1000 * 60 * 60 * 24)) + 1;
                return { today: todayLocal, dayNumber };
            },
            
            updatePuzzleNumber() {
                const { dayNumber } = this.getDateInfo();
                this.elements.puzzleNumber.textContent = dayNumber.toString().padStart(3, '0');
            },
            
            // Storage helpers
            isLocalStorageAvailable() {
                try {
                    const test = '__test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch {
                    return false;
                }
            },
            
            save(key, value) {
                const data = typeof value === 'string' ? value : JSON.stringify(value);
                if (this.isLocalStorageAvailable()) {
                    localStorage.setItem(key, data);
                } else {
                    this.memoryStorage[key] = data;
                }
            },
            
            load(key) {
                const data = this.isLocalStorageAvailable() 
                    ? localStorage.getItem(key) 
                    : this.memoryStorage[key];
                    
                if (!data) return null;
                
                try {
                    return JSON.parse(data);
                } catch {
                    return data;
                }
            },
            
            // Puzzle generation
            generatePuzzle() {
                const { dayNumber } = this.getDateInfo();
                let rng = dayNumber * 1337;
                
                // Random function
                const random = () => {
                    rng = (rng * 1103515245 + 12345) & 0x7fffffff;
                    return rng / 0x7fffffff;
                };
                
                // Keep trying until we get a puzzle with desired difficulty
                let attempts = 0;
                while (attempts < 100) {
                    attempts++;
                    
                    // Start with all light
                    const startGrid = Array(9).fill(true);
                    const targetGrid = Array(9).fill(true);
                    
                    // Apply random moves to create a target pattern
                    const numMoves = 5 + Math.floor(random() * 10); // Try 5-14 moves
                    const appliedMoves = [];
                    
                    for (let i = 0; i < numMoves; i++) {
                        const pos = Math.floor(random() * 9);
                        appliedMoves.push(pos);
                        this.applyMove(targetGrid, pos);
                    }
                    
                    // Verify the minimum moves required
                    const minMoves = this.findMinimumMoves(startGrid, targetGrid);
                    
                    // Accept if it requires 3-7+ moves
                    if (minMoves >= 3 && minMoves <= 12) {
                        // Find the actual optimal solution
                        const solution = this.findOptimalSolution(startGrid, targetGrid);
                        
                        return {
                            start: startGrid,
                            target: targetGrid,
                            optimal: minMoves <= 7 ? minMoves : 7, // Cap display at 7
                            solution: solution
                        };
                    }
                }
                
                // Fallback (shouldn't happen)
                console.warn('Could not generate puzzle with desired difficulty');
                return this.generateFallbackPuzzle(random);
            },
            
            // Find the actual optimal solution path
            findOptimalSolution(startState, targetState) {
                const targetStr = targetState.join('');
                const startStr = startState.join('');
                
                if (startStr === targetStr) return [];
                
                const queue = [[startState, []]];
                const visited = new Set([startStr]);
                
                while (queue.length > 0) {
                    const [currentState, path] = queue.shift();
                    
                    for (let i = 0; i < 9; i++) {
                        const newState = [...currentState];
                        this.applyMove(newState, i);
                        const newStateStr = newState.join('');
                        const newPath = [...path, i];
                        
                        if (newStateStr === targetStr) {
                            return newPath;
                        }
                        
                        if (!visited.has(newStateStr)) {
                            visited.add(newStateStr);
                            queue.push([newState, newPath]);
                        }
                    }
                }
                
                return [];
            },
            
            // Fallback puzzle generation
            generateFallbackPuzzle(random) {
                // Simple fallback that generates a known 3-move puzzle
                const startGrid = Array(9).fill(true);
                const targetGrid = Array(9).fill(true);
                
                // Apply 3 corner moves (guaranteed to need 3 moves to solve)
                this.applyMove(targetGrid, 0);
                this.applyMove(targetGrid, 2);
                this.applyMove(targetGrid, 6);
                
                return {
                    start: startGrid,
                    target: targetGrid,
                    optimal: 3,
                    solution: [0, 2, 6]
                };
            },
            
            // Game logic
            applyMove(grid, index) {
                const positions = this.getAffectedPositions(index);
                positions.forEach(pos => {
                    grid[pos] = !grid[pos];
                });
            },
            
            getAffectedPositions(index) {
                const positions = [index];
                const row = Math.floor(index / 3);
                const col = index % 3;
                
                if (row > 0) positions.push(index - 3);
                if (row < 2) positions.push(index + 3);
                if (col > 0) positions.push(index - 1);
                if (col < 2) positions.push(index + 1);
                
                return positions;
            },
            
            // Load or create puzzle
            loadOrCreatePuzzle() {
                const { dayNumber } = this.getDateInfo();
                const saveKey = `squip-day-${dayNumber}`;
                const saved = this.load(saveKey);
                
                if (saved) {
                    // Load saved state
                    this.grid = saved.grid;
                    this.targetGrid = saved.target;
                    this.moves = saved.moves;
                    this.optimalMoves = saved.optimal;
                    this.solutionMoves = saved.solution;
                    this.isComplete = saved.complete || false;
                    this.moveHistory = saved.moveHistory || [];
                    
                    // Show completion badge if needed
                    if (this.isComplete) {
                        this.showCompletionBadge();
                        this.disableGameplay();
                        this.elements.shareBtn.classList.remove('disabled');
                        
                        // If already completed and won, ensure stats are loaded
                        if (this.checkWin() && !saved.statsUpdated) {
                            // This handles edge case where someone completed before stats feature
                            this.updateStats(this.moves === this.optimalMoves);
                        }
                    }
                } else {
                    // Generate new puzzle
                    const puzzle = this.generatePuzzle();
                    this.grid = [...puzzle.start];
                    this.targetGrid = puzzle.target;
                    this.optimalMoves = puzzle.optimal;
                    this.solutionMoves = puzzle.solution;
                    this.moves = 0;
                    this.isComplete = false;
                    this.moveHistory = [];
                    
                    this.saveState();
                }
                
                this.render();
            },
            
            // Save current state
            saveState() {
                const { dayNumber } = this.getDateInfo();
                const saveKey = `squip-day-${dayNumber}`;
                
                const currentSave = this.load(saveKey);
                
                this.save(saveKey, {
                    grid: this.grid,
                    target: this.targetGrid,
                    moves: this.moves,
                    optimal: this.optimalMoves,
                    solution: this.solutionMoves,
                    complete: this.isComplete,
                    gaveUp: this.isComplete && !this.checkWin(),
                    moveHistory: this.moveHistory,
                    statsUpdated: currentSave?.statsUpdated || false
                });
            },
            
            // Render game
            render() {
                // Update stats
                this.elements.movesCount.textContent = this.moves;
                this.elements.optimalMoves.textContent = this.optimalMoves >= 7 ? '7+' : this.optimalMoves;
                
                // Render player grid
                this.elements.playerGrid.innerHTML = '';
                
                this.grid.forEach((isLight, index) => {
                    const cell = document.createElement('button');
                    cell.className = 'cell' + (isLight ? '' : ' dark');
                    cell.setAttribute('type', 'button');
                    cell.onclick = () => this.handleCellClick(index);
                    
                    if (window.matchMedia('(hover: hover)').matches && !this.isComplete) {
                        cell.onmouseenter = () => this.showPreview(index);
                        cell.onmouseleave = () => this.hidePreview();
                    }
                    
                    this.elements.playerGrid.appendChild(cell);
                });
                
                // Render target grid
                this.elements.targetGrid.innerHTML = '';
                
                this.targetGrid.forEach((isLight) => {
                    const cell = document.createElement('div');
                    cell.className = 'cell' + (isLight ? '' : ' dark');
                    this.elements.targetGrid.appendChild(cell);
                });
            },
            
            // Handle cell click
            handleCellClick(index) {
                if (this.isAnimating || this.isComplete) return;
                
                // Mobile preview mode handling
                if (this.isTouchDevice && this.mobilePreviewEnabled && !this.isComplete) {
                    if (this.previewIndex === index) {
                        // Second tap on same cell - confirm move
                        this.hidePreview();
                        this.previewIndex = -1;
                        this.executeMove(index);
                    } else {
                        // First tap or tap on different cell - show preview
                        this.hidePreview();
                        this.previewIndex = index;
                        this.showPreview(index);
                    }
                } else {
                    // Direct move (desktop or preview disabled)
                    this.executeMove(index);
                }
            },
            
            // Execute the actual move
            executeMove(index) {
                this.isAnimating = true;
                this.moves++;
                
                // Save state for undo (include the clicked index)
                this.moveHistory.push({
                    grid: [...this.grid],
                    clickedIndex: index
                });
                
                // Update move counter
                this.elements.movesCount.textContent = this.moves;
                
                // Hide preview
                this.hidePreview();
                
                // Create ripple effect
                const cell = this.elements.playerGrid.children[index];
                const rect = cell.getBoundingClientRect();
                this.createRipple(rect.left + rect.width / 2, rect.top + rect.height / 2);
                
                // Get affected positions
                const positions = this.getAffectedPositions(index);
                
                // Animate flips
                positions.forEach((pos, i) => {
                    setTimeout(() => {
                        const cell = this.elements.playerGrid.children[pos];
                        cell.classList.add('animating');
                        
                        setTimeout(() => {
                            this.grid[pos] = !this.grid[pos];
                            cell.classList.toggle('dark');
                            cell.classList.remove('animating');
                            
                            // Check win after last animation
                            if (i === positions.length - 1) {
                                setTimeout(() => {
                                    this.isAnimating = false;
                                    this.checkGameState();
                                    this.saveState();
                                    this.updateUndoButton();
                                }, 100);
                            }
                        }, 200);
                    }, i * 50);
                });
            },
            
            // Update undo button state
            updateUndoButton() {
                if (this.moveHistory.length > 0 && !this.isComplete) {
                    this.elements.undoBtn.classList.remove('disabled');
                } else {
                    this.elements.undoBtn.classList.add('disabled');
                }
            },
            
            // Undo last move
            undo() {
                if (this.isAnimating || this.isComplete || this.moveHistory.length === 0) return;
                
                // Clear any active preview
                this.hidePreview();
                
                // Get the last move
                const lastMove = this.moveHistory.pop();
                
                // Restore the grid state from before the move
                this.grid = [...lastMove.grid];
                
                // Re-render the grid
                this.render();
                
                // Save state and update undo button
                this.saveState();
                this.updateUndoButton();
                
                // Show message
                this.showMessage('Move undone');
            },
            
            // Check if puzzle is solved
            checkWin() {
                return this.grid.every((cell, i) => cell === this.targetGrid[i]);
            },
            
            // Check game state
            checkGameState() {
                if (this.checkWin()) {
                    this.handleWin();
                }
            },
            
            // Handle win
            handleWin() {
                this.isComplete = true;
                const isPerfect = this.moves === this.optimalMoves || (this.optimalMoves === 7 && this.moves === 7);
                const stats = this.updateStats(isPerfect);
                this.saveState();
                this.showCompletionBadge();
                this.disableGameplay();
                this.elements.shareBtn.classList.remove('disabled');
                this.createCelebration();
                
                // Show result modal with stats
                setTimeout(() => {
                    const title = document.getElementById('result-title');
                    const subtitle = document.getElementById('result-subtitle');
                    
                    if (isPerfect) {
                        title.textContent = 'Perfect!';
                        subtitle.innerHTML = `You found the optimal solution in ${this.moves} moves!<br><br>`;
                    } else {
                        title.textContent = 'Solved!';
                        const optimalText = this.optimalMoves >= 7 ? '7+' : this.optimalMoves;
                        subtitle.innerHTML = `You solved it in ${this.moves} moves (optimal: ${optimalText})<br><br>`;
                    }
                    
                    // Add stats in horizontal layout
                    let statsHTML = `<div style="display: flex; justify-content: space-around; align-items: center; background: var(--primary-bg); padding: 20px; border-radius: 12px; margin-top: 20px; margin-bottom: 10px;">`;
                    statsHTML += `<div style="text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.currentStreak}</div>
                        <div style="font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 6px; line-height: 1.2;">Current<br>Streak</div>
                    </div>`;
                    statsHTML += `<div style="text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.longestStreak}</div>
                        <div style="font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 6px; line-height: 1.2;">Longest<br>Streak</div>
                    </div>`;
                    statsHTML += `<div style="text-align: center;">
                        <div style="font-size: 28px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.perfectScores}</div>
                        <div style="font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 6px; line-height: 1.2;">Perfect<br>Scores</div>
                    </div>`;
                    statsHTML += `</div>`;
                    subtitle.innerHTML += statsHTML;
                    
                    this.elements.resultOverlay.classList.add('show');
                }, 500);
            },
            
            // Show completion badge
            showCompletionBadge() {
                const existing = this.elements.subtitle.querySelector('.completed-indicator');
                if (existing) return;
                
                const badge = document.createElement('span');
                badge.className = 'completed-indicator';
                
                if (!this.checkWin()) {
                    badge.textContent = 'Incomplete';
                    badge.classList.add('failed');
                } else if (this.moves === this.optimalMoves) {
                    badge.textContent = 'Perfect';
                    badge.classList.add('perfect');
                } else {
                    badge.textContent = 'Completed';
                }
                
                // Make badge clickable if completed successfully
                if (this.checkWin()) {
                    badge.style.cursor = 'pointer';
                    badge.onclick = () => this.showResultModal();
                }
                
                this.elements.subtitle.appendChild(badge);
            },
            
            // Disable gameplay
            disableGameplay() {
                const cells = this.elements.playerGrid.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.style.cursor = 'default';
                    cell.onclick = null;
                    cell.onmouseenter = null;
                    cell.onmouseleave = null;
                });
                
                this.elements.resetBtn.classList.add('disabled');
                this.updateUndoButton();
            },
            
            // Reset tiles
            resetTiles() {
                if (this.isAnimating || this.isComplete) return;
                
                this.grid = Array(9).fill(true);
                this.moveHistory = []; // Clear move history on reset
                this.previewIndex = -1; // Clear preview
                this.render();
                this.saveState();
                this.updateUndoButton();
                this.showMessage('Board reset');
            },
            
            // Show/hide preview
            showPreview(index) {
                if (this.isAnimating || this.isComplete) return;
                
                const positions = this.getAffectedPositions(index);
                positions.forEach(pos => {
                    const cell = this.elements.playerGrid.children[pos];
                    if (this.grid[pos]) {
                        cell.classList.add('preview-dark');
                    } else {
                        cell.classList.add('preview-light');
                    }
                    
                    // Add preview-affected to adjacent tiles (not the clicked one)
                    if (pos !== index) {
                        cell.classList.add('preview-affected');
                    }
                });
                
                // Add selected indicator to the clicked tile
                const clickedCell = this.elements.playerGrid.children[index];
                clickedCell.classList.add('preview-selected');
            },
            
            hidePreview() {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.classList.remove('preview-dark', 'preview-light', 'preview-selected', 'preview-affected');
                });
                this.previewIndex = -1;
            },
            
            // Solution handling
            showSolution() {
                if (!this.isComplete) {
                    // Show confirmation
                    this.elements.solutionConfirmOverlay.classList.add('show');
                } else {
                    // Show solution directly
                    this.displaySolution();
                }
            },
            
            confirmSolution() {
                // Mark as gave up
                this.isComplete = true;
                this.resetStreak(); // Reset streak when giving up
                this.saveState();
                this.showCompletionBadge();
                this.disableGameplay();
                this.elements.shareBtn.classList.remove('disabled');
                
                // Close confirmation and show solution
                this.elements.solutionConfirmOverlay.classList.remove('show');
                this.displaySolution();
            },
            
            cancelSolution() {
                this.elements.solutionConfirmOverlay.classList.remove('show');
            },
            
            viewSolutionFromResult() {
                this.elements.resultOverlay.classList.remove('show');
                this.displaySolution();
            },
            
            displaySolution() {
                const stepsContainer = document.getElementById('solution-steps');
                stepsContainer.innerHTML = '';
                
                // Start with fresh grid
                let currentGrid = Array(9).fill(true);
                
                // Show starting grid
                const startStep = document.createElement('div');
                startStep.className = 'solution-step';
                startStep.appendChild(this.createSolutionGrid(currentGrid, -1));
                stepsContainer.appendChild(startStep);
                
                // Show each move
                this.solutionMoves.forEach((moveIndex) => {
                    // Add arrow
                    const arrow = document.createElement('div');
                    arrow.className = 'solution-arrow';
                    arrow.textContent = '↓';
                    stepsContainer.appendChild(arrow);
                    
                    // Apply move
                    this.applyMove(currentGrid, moveIndex);
                    
                    // Show grid
                    const step = document.createElement('div');
                    step.className = 'solution-step';
                    step.appendChild(this.createSolutionGrid(currentGrid, moveIndex));
                    stepsContainer.appendChild(step);
                });
                
                this.elements.solutionOverlay.classList.add('show');
            },
            
            createSolutionGrid(gridState, clickedIndex) {
                const grid = document.createElement('div');
                grid.className = 'solution-grid';
                
                const affectedCells = clickedIndex >= 0 ? this.getAffectedPositions(clickedIndex) : [];
                
                gridState.forEach((isLight, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'solution-cell' + (isLight ? '' : ' dark');
                    
                    if (index === clickedIndex) {
                        cell.classList.add('clicked');
                    } else if (affectedCells.includes(index)) {
                        cell.classList.add('affected');
                    }
                    
                    grid.appendChild(cell);
                });
                
                return grid;
            },
            
            closeSolution() {
                this.elements.solutionOverlay.classList.remove('show');
            },
            
            // Share results
            shareResults() {
                if (this.elements.shareBtn.classList.contains('disabled')) return;
                
                const { dayNumber } = this.getDateInfo();
                const won = this.checkWin();
                
                // Generate grid visualization of target pattern
                let gridVisual = '';
                for (let i = 0; i < 9; i++) {
                    if (i > 0 && i % 3 === 0) {
                        gridVisual += '\n';
                    }
                    gridVisual += this.targetGrid[i] ? '🟦' : '⬛';
                }
                
                let resultText = `SQUIP #${dayNumber.toString().padStart(3, '0')}\n`;
                resultText += `${gridVisual}\n\n`;
                
                if (!this.isComplete) {
                    // This shouldn't happen since button is disabled, but just in case
                    return;
                } else if (!won) {
                    resultText += `❌ Couldn't solve today's puzzle.\n`;
                    resultText += `Try it yourself at https://squip.io`;
                } else if (this.moves === this.optimalMoves) {
                    resultText += `⭐ PERFECT! Solved in ${this.moves} moves!\n`;
                    resultText += `Try and match my score at https://squip.io`;
                } else {
                    resultText += `✅ Solved in ${this.moves} moves!\n`;
                    resultText += `Try and beat my score at https://squip.io`;
                }
                
                navigator.clipboard.writeText(resultText).then(() => {
                    this.showMessage('Copied to clipboard!');
                }).catch(() => {
                    this.showMessage('Failed to copy');
                });
            },
            
            // UI helpers
            showMessage(text) {
                this.elements.message.textContent = text;
                this.elements.message.classList.add('show');
                setTimeout(() => this.elements.message.classList.remove('show'), 2500);
            },
            
            showTutorial() {
                this.elements.tutorialOverlay.classList.add('show');
            },
            
            closeTutorial() {
                this.elements.tutorialOverlay.classList.remove('show');
                this.save('squip-has-played', 'true');
            },
            
            closeResult() {
                this.elements.resultOverlay.classList.remove('show');
            },
            
            // Show result modal with current stats
            showResultModal() {
                const stats = this.load('squip-stats') || { currentStreak: 0, longestStreak: 0, perfectScores: 0 };
                const title = document.getElementById('result-title');
                const subtitle = document.getElementById('result-subtitle');
                
                if (this.moves === this.optimalMoves) {
                    title.textContent = 'Perfect!';
                    subtitle.innerHTML = `You found the optimal solution in ${this.moves} moves!<br><br>`;
                } else {
                    title.textContent = 'Solved!';
                    const optimalText = this.optimalMoves >= 7 ? '7+' : this.optimalMoves;
                    subtitle.innerHTML = `You solved it in ${this.moves} moves (optimal: ${optimalText})<br><br>`;
                }
                
                // Add stats in horizontal layout
                let statsHTML = `<div style="display: flex; justify-content: space-around; align-items: center; background: var(--primary-bg); padding: 20px; border-radius: 12px; margin-top: 20px; margin-bottom: 10px;">`;
                statsHTML += `<div style="text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.currentStreak}</div>
                    <div style="font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 6px; line-height: 1.2;">Current<br>Streak</div>
                </div>`;
                statsHTML += `<div style="text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.longestStreak}</div>
                    <div style="font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 6px; line-height: 1.2;">Longest<br>Streak</div>
                </div>`;
                statsHTML += `<div style="text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.perfectScores}</div>
                    <div style="font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 6px; line-height: 1.2;">Perfect<br>Scores</div>
                </div>`;
                statsHTML += `</div>`;
                subtitle.innerHTML += statsHTML;
                
                this.elements.resultOverlay.classList.add('show');
            },
            
            checkFirstTime() {
                if (!this.load('squip-has-played')) {
                    setTimeout(() => this.showTutorial(), 500);
                }
            },
            
            showStats() {
                const stats = this.load('squip-stats') || { currentStreak: 0, longestStreak: 0, perfectScores: 0 };
                const content = document.getElementById('stats-content');
                
                let statsHTML = `<div style="display: flex; justify-content: space-around; align-items: center; background: var(--primary-bg); padding: 25px; border-radius: 12px; margin-top: 10px;">`;
                statsHTML += `<div style="text-align: center;">
                    <div style="font-size: 32px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.currentStreak}</div>
                    <div style="font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 8px; line-height: 1.3;">Current<br>Streak</div>
                </div>`;
                statsHTML += `<div style="text-align: center;">
                    <div style="font-size: 32px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.longestStreak}</div>
                    <div style="font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 8px; line-height: 1.3;">Longest<br>Streak</div>
                </div>`;
                statsHTML += `<div style="text-align: center;">
                    <div style="font-size: 32px; font-weight: 700; color: var(--primary-color); line-height: 1;">${stats.perfectScores}</div>
                    <div style="font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 8px; line-height: 1.3;">Perfect<br>Scores</div>
                </div>`;
                statsHTML += `</div>`;
                
                content.innerHTML = statsHTML;
                this.elements.statsOverlay.classList.add('show');
            },
            
            closeStats() {
                this.elements.statsOverlay.classList.remove('show');
            },
            
            showSettings() {
                // Set toggle state
                const toggle = document.getElementById('mobile-preview-toggle');
                toggle.checked = this.mobilePreviewEnabled;
                
                // Disable toggle if not on touch device
                const toggleSwitch = toggle.closest('.toggle-switch');
                if (!this.isTouchDevice) {
                    toggleSwitch.classList.add('disabled');
                    toggle.disabled = true;
                } else {
                    toggleSwitch.classList.remove('disabled');
                    toggle.disabled = false;
                }
                
                // Update color picker selection
                document.querySelectorAll('.color-option').forEach(option => {
                    if (option.dataset.color === this.currentColor) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
                
                this.elements.settingsOverlay.classList.add('show');
            },
            
            closeSettings() {
                this.elements.settingsOverlay.classList.remove('show');
            },
            
            toggleMobilePreview() {
                if (!this.isTouchDevice) return;
                
                const toggle = document.getElementById('mobile-preview-toggle');
                this.mobilePreviewEnabled = toggle.checked;
                this.save('squip-mobile-preview', this.mobilePreviewEnabled);
                
                // Clear any active preview
                if (!this.mobilePreviewEnabled) {
                    this.hidePreview();
                }
            },
            
            changeColor(colorName) {
                if (!this.colorThemes[colorName]) return;
                
                this.currentColor = colorName;
                this.save('squip-color-theme', colorName);
                this.applyColorTheme(colorName);
                
                // Update color picker selection
                document.querySelectorAll('.color-option').forEach(option => {
                    if (option.dataset.color === colorName) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
            },
            
            applyColorTheme(colorName) {
                const theme = this.colorThemes[colorName];
                const root = document.documentElement;
                
                root.style.setProperty('--primary-color', theme.primary);
                root.style.setProperty('--primary-hover', theme.hover);
                root.style.setProperty('--primary-light', theme.light);
                root.style.setProperty('--primary-dark', theme.dark);
                root.style.setProperty('--primary-bg', theme.bg);
                root.style.setProperty('--primary-rgb', theme.rgb);
            },
            
            createRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                ripple.style.width = '20px';
                ripple.style.height = '20px';
                ripple.style.left = (x - 10) + 'px';
                ripple.style.top = (y - 10) + 'px';
                document.body.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            },
            
            createCelebration() {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const x = Math.random() * window.innerWidth;
                        const y = window.innerHeight / 2;
                        this.createParticles(x, y, 10);
                    }, i * 200);
                }
            },
            
            createParticles(x, y, count) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'particle';
                        particle.style.left = x + (Math.random() - 0.5) * 40 + 'px';
                        particle.style.top = y + (Math.random() - 0.5) * 40 + 'px';
                        document.getElementById('particles').appendChild(particle);
                        setTimeout(() => particle.remove(), 1000);
                    }, i * 50);
                }
            }
        };
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            Game.init();
            
            // Add click handler to clear preview when clicking outside grid
            document.addEventListener('click', (e) => {
                if (Game.previewIndex !== -1 && 
                    !e.target.closest('#player-grid') && 
                    !e.target.closest('.cell')) {
                    Game.hidePreview();
                }
            });
        });
    </script>
</body>
</html>
